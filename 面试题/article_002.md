# .NET 面试题总结 第2部分

#### Web Service 数据传输有什么限制？为什么？DataTable可以作为Web Service参数传递吗？

所传输的数据必须是可序列化的。因为需要转换为XML格式以可以穿越防火墙，做到真正的数据共享。因为DataSet处理DataTable的序列化以便进行封送处理，所以无法传递单个DataTable；

在 ADO.NET 的三个基本数据对象 — DataReader、DataTable 和 DataSet 中，只有 DataSet 可以与 Web 服务之间传递。这是因为，为了与 Web 服务进行通信，对象必须是可序列化的(序列化是一个过程，它用于将对象的公共属性转换为 XML，并且因为 XML 只是纯文本，所以可以将其从一个应用程序传输到另一个应用程序，并且可以穿越防火墙，从而克服了 COM 的主要障碍之一)。DataReader 无法序列化，因为它们需要到服务器的开放连接。并且，因为 DataSet 处理 DataTable 的序列化以便进行封送处理，所以您也无法传递单个 DataTable；

#### 常用的调用 Web Service 方法有哪些？
可以从浏览器、ASP页或其他Web服务调用可以使用 HTTP-GET、HTTP-POST 访问 Web 服务也可以从ASP页或其他Web服务向其他Web服务发出SOAP请求 HTTP-GET、HTTP-POS、SOAP 使用Web服务代理；

#### 使用ASMX的 XML Web 服务与使用SOAP的.Net Remoting的区别？

SOAP是简单对象访问协议，Web服务正是通过WSDL来约定服务器和客户端基于XML的SOAP来通讯，而无论客户端和服务器都不需要知道对方的平台、编程语言等信息；

.Net Remoting 本质是为了交互更为复杂的对象，甚至需要管理远程对象的生命周期，所以客户端必须了解服务器对象的详细信息，虽然 .Net Remoting 支持使用 SOAP，但对于客户端来说还是必须了解服务器对象的详细信息；

Web服务使用的消息机制，而Remoting采用的RPC。Web Service 能用于不同平台，不同语言，Remoting只适用于.Net。效率上 Remoting 高于 XML Web Service；

#### 解释一下UDDI、WSDL的意义及其作用？

UDDI 统一描述、发现和集成协议(UDDI，Universal De script ion，Discovery and Integration)是一套基于Web的、分布式的、为Web服务提供的信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web服务 注册以使得别的企业能够发现的访问协议的实现标准。UDDI 提供了一组基于标准的规范用于描述和发现服务，还提供了一组基于因特网的实现；

WSDL 描述Web服务的公共接口。这是一个基于XML的关于如何与Web服务通讯和使用的服务描述。这是一个基于XML的，关于如何与Web服务通讯和使用的服务描述；

#### 装箱和拆箱的含义？

装箱：将值类型转换为引用类型；

拆箱：将引用类型转换为值类型；

装箱是值类型到 object 类型或到该值类型所实现的任何接口类型的隐式转换。将一个值的值装箱会分配一个对象实例并将该值复制到新的对象中；

取消装箱是从 object 类型到值类型或从接口类型到实现该接口的值类型的显式转换。取消装箱操作包括：检查对象实例，确保它是给定值类型的一个装箱值；

#### 页面生命周期？
页面生命周期执行一系列步骤：页面的初始化、实例化控件、还 原和维护状态、运行事件处理程序代码、呈现。为了在合适的阶段执行所需的代码，所以要对页面生命周期非常熟悉。在页生命周期的各个阶段，页面会逐个引发定 义的事件，通过对代码开发，在页面的生命事件中执行我们所需要的程序；

页生命周期阶段？
1、页请求：发生在页面生命周期之前，用户请求页时，ASP.NET 将确定是否需要分析和编译页，从而确定是否开始页面的生命周期，或者是否可以在不运行页的情况下发送页面缓存以进行响应；
2、开始：设置页属性，如：HttpContext 以及其他属性；在此阶段，页面需要确定是回发请求还是新请求，并设置 IsPostBack 属性；设置页面的 UICulture 属性；
3、页面初始化：加载所有主题；控件生成，并设置 UniqueID；
注：ViewState、ControlState中的值还未加载至控件；如果页面是回发，则回发数据也还未加载；故此时控件可以访问，但值可能出错；
4、加载：如果当前请求是回发请求，则为控件加载 ViewState 和 ControlState 中的值；
5、验证：调用所有验证程序控件的 Validate 方法，此方法将设置验证程序控件和页的 IsValid 属性；
6、回发事件处理：如果请求是回发请求，则调用所有事件处理程序；
7、呈现：首先对该页和所有控件进行保存视图状态，然后对每个控件调用 Render 方法，它会提供一个文本编写器，用于将控件的输入写入页的 Response 属性的 OutputStream 中；
8、卸载：完成呈现，并已将页发送至客户端、准备丢弃该页后，调用卸载。将卸载属性如：Response和Request等等；

#### 页生命周期事件？

1、PreInit
完成操作：检查IsPostBack属性来确定是不是第一次处理该页；创建或重新创建动态控件；动态设置主控页；动态设置Theme属性；读取或设置配置文件属性；
注：如果请求是回发请求，则控件的值尚未从视图状态恢复，即：不应该在此事件中设置控件属性。

2、Init
完成操作：在所有控件都已经初始化并且应用所有外观设置后引发。使用该事件来读取和初始化控件属性；

3、InitComplete
完成操作：由Page对象引发，使用该事件来处理要求完成所有初始化工作的任务；

4、PreLoad
完成操作：为页和所有控件加载视图状态，然后处理 Request 实例包括的任何回发数据；
注：如果需要在Load之前对页或控件进行处理，需要该事件；

5、Load
完成操作：以递归方式加载所有控件；

6、控件事件
完成操作：处理控件引发的事件；
注：在回发请求中，如果页包含验证程序控件，请在执行任何处理之前检查Page和各个验证控件的IsValid属性；

7、LoadComplete

8、PreRender
在控件输出前最后的修改机会；
注：在该事件发生前的操作：Page对所有控件递归进行EnsureChildControl操作、设置了DataSourceID属性的数据绑定控件会调用DataBind方法；

9、SaveStateComplete
在该事件发生前，已经对控件的ViewState进行了保存。将忽略对页和控件所作的所有修改；

10、Render
方法，便于开发；

11、UnLoad


大概描述一下ASP.NET服务器控件的生命周期？
初始化、加载视图状态、处理回发数据、加载、发送回发更改通知、处理回发事件、预呈现、保存状态、呈现、处置、卸载；

#### 应用程序生命周期？

在应用程序的生命周期期间，应用程序会引发可处理的事件并调 用可重写的特定方法。若要处理应用程序事件或方法，可以在应用程序根目录中创建一个名为 Global.asax 的文件。如果创建了 Global.asax文件，ASP.NET 会将其编译为从 HttpApplication 类派生的类，然后使用该派生类表示应用程序；

HttpApplication 进程的一个实例每次只处理一个请求。由于在访问应用程序类中的非静态成员时不需要将其锁定，这样可以简化应用程序的事件处理过程。这样还可以将特定于请求 的数据存储在应用程序类的非静态成员中。例如，可以在 Global.asax 文件中定义一个属性，然后为该属性赋一个特定于请求的值；

Application_Start 和 Application_End 方法是不表示 HttpApplication 事件的特殊方法。在应用程序域的生命周期期间，ASP.NET 仅调用这些方法一次，而不是对每个 HttpApplication 实例都调用一次；

#### ASP.NET 页面在什么时候产生？又在什么时候销毁？

1、Page_Init() —— 初始化对象
这一过程主要是初始化包括页面本身的所有控件，每次的页面载入就会执行一次初试过程，而在这里面访问到的也是控件的初始值。还有就是可以通过OnInit()来重载初试化事件；

2、LoadViewState() —— 导入ViewState数据
在初试化事件后，在 LoadViewState 事件中所有控件将获得他们的第一个属性 ViewState 属性，这个属性最终将被返回给服务器以判断这个页面是已经被用户访问完毕还是仍然在被用户所访问。也可重 LoadViewState 事件对相应的控件进行值设定；

3、LoadPostData() —— 用 LoadPostData 处理 Postback 数据
Postback数据也可以理解成就是服务器页面提交的表单数据，每一次表单数据的提交都会触发执行 IPostBackDataHandler 接口操作的控件；

4、Page_Load() —— 导入对象
这个过程就比较熟悉了，也是在页面的每次载入时一定会执行， 但是注意和 PageInit() 之间的区别，所有的对象第一次被布置在 DOM 页面(在ASP.NET中称控件树)里了并且可以通过代码或是相关的位置被引用。这样，对象就可以很容易的从客户端获得诸如宽度、高度、值、可见性等在 HTML中的属性值。经常会用到的Page.IsPostBack()指示该页是否正为响应客户端回发而加载，或者它是否正被首次加载和访问；

5、Handle Control Events —— 具体的控件事件
这个过程执行的是相应具体控件事件；

6、Page_PreRender() —— 预先呈递对象
预先呈递对象可以改变对象并将改变保存的最后时刻。可以对控件的属性、控件树的结构等做出最后的修改，同时还不用考虑ASP.NET对其作出任何改变，因为此时已经脱离了数据库调用以及 ViewState 更新了，也可以通过OnPreRender来重载；

7、Page_Render() —— 呈递对象呈递页面
所有对页面控件的修改完成后 ViewState就被保存了。运用HTML创建给浏览器输出的页面的时候Render事件就发生了。在Render事件过程中，页面调用其中的对象将它 们呈递给HTML。然后，页面就可以以HTML的形式被用户的浏览器访问了。当Render事件被重载时，开发者可以编写自定义的HTML代码使得原先生 成的HTML都无效而按照新的HTML来组织页面。Render方法将一个 HtmlTextWriter 对象作为参数并用它将HTML在浏览器上以网页的形式显示。这时仍然可以做一些修改动作，不过它们只是客户端的一些变化而已了。亦可以重载Render事 件；

8、Unload event —— 卸载对象
当想服务器请求一个对象的时候，就会在内存里生成一个继承页面对象，也就是页面的类，它继承自System.Web.UI.Page。当页面对象从内存中卸载时发生，将触发该事件；

9、Dispose method called
在呈递给HTML完成后，所有的对象都应被销毁。在Dispose事件中，你应该销毁所有在建立这个页面时创建的对象。这时所有的处理已经完毕，所以销毁任何剩下的对象都是不会产生错误的，包括页面对象。你可以重载Dispose事件；

#### 如何部署一个ASP.NET页面？
VS2005 和 VS2003 都有发布机制，VS2003可以发布然后再复制部署，VS2005基本上可以直接部署到对应位置；

#### Session有什么重大Bug？微软提出了什么方法加以解决？
是IIS中由于有进程回收机制，系统繁忙的话Session 会丢失，可以用 State Server 或 SQL Server 数据库的方式存储Session不过这种方式比较慢，而且无法捕获Session的End事件。当然这种种情况是限于MS的IIS的Web容器，不是每个 容器都有这种问题；

#### 如何处理几十万条并发数据？
用存储过程或事务。取得最大标识的时候同时更新。注意主键不是自增量方式这种方法并发的时候是不会有重复主键的，取得最大标识要有一个存储过程来获取；

#### 谈谈 fina、finally、finalize的区别？

final 修饰符 (.Net中不存在此修饰符) —— 如果一个类被声明为 final ，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract 的，又被声明为final的。将变量或方法声明为 final ，可以保证它们在使用中不被改变。被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载；

finally —— 在异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块(如果有的话)；

finalize —— 方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的；

#### `short s1 = 1; s1 = s1 + 1;`有什么错？`short s1 = 1; s1 += 1;`有什么错？

`short s1 = 1; s1 = s1 + 1`，有错，s1是short型，s1+1是int型，不能显式转化为short型。可修改为`s1 =(short)(s1 + 1); short s1 = 1; s1 += 1`，正确；

#### sleep() 和 wait() 有什么区别？

sleep()：为当前线程指定挂起的时间，是使线程停止一段时间，在sleep 时间间隔期满后，线程不一定立即恢复执行。这是因为在那个时刻，其它线程可能正在运行而且没有被调度为放弃执行，除非“醒来”的线程具有更高的优先级；

wait()：释放对象上的锁，并阻塞当前线程，直到它重新获取该锁。线程交互时，如果线程对一个同步对象x 发出一个wait()调用，该线程会暂停执行，被调对象进入等待状态，直到被唤醒或等待时间到；

#### 数组有没有length()这个方法？String有没有length()这个方法？
数组和 String 都没有Length()方法，只有Length属性；

#### Set里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用==还是equals()？它们有何区别？

Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值；

#### List、Set、Map是否继承自Collection接口？
List，Set是，Map不是；

#### abstract的method是否可同时是static，是否可同时是native，是否可同时是synchronized？
都不能；

#### 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法？
不能，一个对象的一个synchronized方法只能由一个线程访问；

#### swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上？
switch(expression)中，expression是一个整型，字符或字符串，因此可以作用在byte和long上，也可以作用在string上；

#### 两个对象值相同(x.equals(y) == true)，但却可有不同的 Hash Code，这句话对不对？
不对，有相同的 Hash Code ；

#### try {}里有一个 return 语句，那么紧跟在这个try后的 finally {}里的code会不会被执行？什么时候被执行？在return前还是后？
会执行，在return前执行；

#### 构造器 Constructor 是否可被override？
构造器Constructor不能被继承，因此不能重写(override)，但可以被重载(overload)；

#### 接口是否可继承接口？抽象类是否可实现(implements)接口？抽象类是否可继承实体类(concrete class)？
接口可以继承接口；抽象类可以实现(implements)接口；抽象类可继承实体类，但前提是实体类必须有明确的构造函数；

#### 启动一个线程是用run()还是start()？
启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程；

#### `String s = new String("xyz");` 创建了几个String Object？

对Java来说两个对象，一个是"xyx"，一个是指向"xyx"的引用对象s；

对.NET来说该题是错误的，根本就没这样的构造函数。`String a="xyz";`首先会到常量池中去查找，如果存在就不再分配，如果不存在就分配，常量池中的数据是在编译期赋值的，也就是生成class文件时就把它放到常量池里了；

#### GC是什么？为什么要有GC？
GC是垃圾收集器，程序员不用担心内存管理，因为垃圾收集器会自动进行管理；

#### 能用 foreach 遍历访问的对象需要实现IEnumerable接口或声明
GetEnumerator方法的类型；

#### 在.Net中，配件的意思是？
程序集(中间语言、源数据、资源、装配清单)；

#### 什么叫应用程序域？

一种边界，它由公共语言运行库围绕同一应用程序范围内创建的对象建立(即从应用程序入口点开始，沿着对象激活的序列的任何位置)；

应用程序域有助于将在一个应用程序中创建的对象与在其他应用程序中创建的对象隔离，以使运行时行为可以预知，隔离正在运行的应用程序；

在一个单独的进程中可以存在多个应用程序域。应用程序域可以理解为一种轻量级进程。起到安全的作用。占用资源小；

就是为安全性、可靠性、隔离性和版本控制，以及卸载程序提供的隔离边界。它通常由运行库宿主创建，应用程序域提供了一个更安全，用途更广的处理单元；

#### 什么是强类型？什么是弱类型？哪种更好些？为什么？
强类型是在编译的时候就确定类型的数据，在执行时类型不能更 改，而弱类型在执行的时候才会确定类型。没有好不好，二者各有好处，强类型安全，因为它事先已经确定好了，而且效率高。一般用于编译型编程语言，如 C++、Java、C#、Pascal等，弱类型相比而言不安全，在运行的时候容易出现错误，但它灵活，多用于解释型编程语言，如Java script ，VB等；

#### 什么是受管制的代码？什么是强类型和弱类型系统？CTS、CLS和CLR分别作何解释？
1、受管制的代码：在.Net环境中运行的任何代码都称为受管制的代码(Managed code)，.Net外部的其他代码也运行在Windows上，这些代码称为未受管制的代码(Unmanaged code)；

2、强类型和弱类型的区别在与，在编码过程中是否要指定数据 类型，作为强类型必须指定数据类型，编译器为其分配相应的存储空间(如C、Pascal)否则编译出错。而弱类型不一定需要指定数据类型，编译器会用相同 的空间去分配各种类型，除非你指定了(如Basic)。作为强类型语言，在编译阶段的安全性要高于弱语言型；

3、CLR(Common Language Runtime)的全称是公共语言运行库，读者可以把CLR理解为一个包含运行.NET程序的引擎和一堆符合公共语言基础结构的类库的集合。CLR是一个 规范的实现，我们开发的几乎所有的。NET程序都基于CLR的类库来实现，并且运行在CLR提供的运行引擎之上。所谓.Net框架，指的就是公共语言运行 库；公共语言基础(CLI)是微软公司向ECMA提交的一份语言和数据格式规范，CLR是目前为止唯一一个公共语言基础的实现版本；

CTS(Common Type System)的全称是通用类型系统。前文已经介绍了公共语言基础(CLI)的概念，微软公司提交的CLI规范，包括了公共类型系统(CTS)、公共中间 语言(CIL)、底部文件格式以及元数据格式等。公共类型系统定义了一个能够在CLR上运行的语言规范。尽管有很多语言本身不符合CTS规范，但是通过加 强编译器，改变语言附加规范等手段，使得许多语言能够编写出能在CLR上运行的程序；
一种语言编写的程序编译能够在CLR上运行，并不代表这种语言本身完全符合CTS的规范。例如C++语言，仍然保持了其不符合CTS规范的部分，并且在编译时把这部分不符合CTS的代码编译成原始代码而非中间代码；

CLS(Common Language Specification)的全称是通用语言规范，是CTS的一个子集，它定义了希望编写在.Net平台上运行的程序的语言所需符合的最小规范。正因 为.Net允许由不同语言编写的程序一起执行，所以才制定出CLS规范，用以避免不同语言特性产生的错误；

#### .Net中哪项技术(CLR、CTS、CLS)实现跨多语言？
CLR

#### CLR与IL分别是什么含义？

CLR(公共语言运行库)：能管理内存，能够轻松地设计其对 象可以跨语言互动的组件和应用程序，编译一次，并可以在任何支持运行库的CPU和操作系统上运行，跨语言集成(特别是跨语言继承)公共语言运行时，类似于 Java中的JVM，Java虚拟机；在.Net环境下，各种编程语言使用一种共同的基础资源环境，这就是CLR，CLR将直接与操作系统进行通信，而编 程语言如C#将尽量避免直接与操作系统直接通信，加强了程序代码的执行安全性，可以这样看：CLR就是具体的编程语言如：C#与操作系统之间的翻译，同时 它为具体的编程语言提供了许多资源；

IL(中间语言)：可用于语言互操作性，IL不是字节代码， 但很接近字节代码，因此执行应用程序时，IL到机器代码的转换要快很多。独立于CPU的指令集。由CLR转换为特定于CPU的代码。IL中间语言，也称 MSIL，微软中间语言，或CIL，通用中间语言；所有.Net源代码(不管用哪种语言编写)在进行编译时都被编译成IL。在应用程序运行时被即时 (Just-In-Time，JIT)编译器处理成为机器码，被解释及执行；

#### 对象能否调用静态方法？
对象能调用静态方法；

#### PID是什么？在做系统的故障排除时如何使用它？
PID是进程编号，在系统发现故障的时候，可以根据它寻找故障所发生的具体进程，并且可通过Visual Studio等IDE将故障进程附加到进程中进行调试(Debug)；

#### 单个TCP/IP端口上能够被多少个进程侦听？
１个；

#### 描述一下C#中索引器的实现过程，是否只能根据数字进行索引？
索引器可以使客户程序很方便地访问类中的集合或数组，类似通过索引访问数组，并且索引器向客户程序隐藏了内部的数据结构。类似于属性，访问类或结构的集合或数组时，可以用索引器实现，索引器用this关键字声明。索引器可以用任意类型进行索引；

#### MVC模式？
MVC(Model View Controller)模型——视图——控制器；
模型负责业务领域的事情，视图负责显示的事情，控制器把数据读取出来填充模型后把模型交给视图去处理。而各种验证应该是在模型里处理了。它强制性的使应用程序的输入、处理和输出分开。MVC最大的好处是将逻辑和页面分离；

#### Assembly.Load("foo.dll"); 这句话是否正确？
错误，正确的应该是Assembly.Load("foo"); 或者Assembly.LoadFrom("foo.dll");

#### DateTime是否可以为null？
不能，因为其为Struct类型，而结构属于值类型，值类型不能为null，只有引用类型才能被赋值null；

#### using() 语法有用吗？什么是 IDisposable ？
有用，实现了 IDisposiable 的类在using中创建，using结束后会自定调用该对象的Dispose方法，释放资源；

#### 三层架构，用.Net做B/S结构的系统，您是用几层结构来开发？每一层之间的关系以及为什么要这样分层？

表现层(UI)、业务逻辑层(BLL)、数据访问层(DAL)。目的即为了“高内聚，低耦合”的思想；

表现层(UI)：通俗讲就是展现给用户的界面，即用户在使用一个系统的时候的所见所得；

业务逻辑层(BLL)：业务层一般分为二层，业务表观层实现与表示层的沟通，业务规则层实现用户密码的安全等；

表示层：为了与用户交互例如用户添加表单针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理；

数据访问层(DAL)：该层所做事务直接操作数据库，针对数据的增添、删除、修改、更新、查找等；

每层之间是一种垂直的关系；

三层结构是N层结构的一种，一般来说，层次之间是向下依赖的，下层代码未确定其接口(契约)前，上层代码是无法开发的，下层代码接口(契约)的变化将使上层的代码一起变化；

优点：分工明确，条理清晰，易于调试，而且具有可扩展性；

缺点：增加成本；

#### C#函数中无参数修饰符、out修饰符、params修饰符、ref修饰符的区别？
无参数修饰符：表示按值传递；
out修饰符：表示按引用传递，传递前不需赋初值，但在传入的方法内赋值，否则报错；
ref修饰符：表示按引用传递，传递前必须赋初值，否则报错；
params修饰符：可将不确定个数的一组相同类型的数据作为参数传递，函数签名中只能有一个params修饰符，并且应为最后一个参数；

#### ref与out有什么不同？

方法参数上的 ref 方法参数关键字使方法引用传递到方法的同一个变量。当控制传递回调用方法时，在方法中对参数所做的任何更改都将反映在该变量中。若要使用 ref 参数，必须将参数作为 ref 参数显式传递到方法。ref 参数的值被传递到 ref 参数。传递到 ref 参数的参数必须最先初始化。将此方法与 out参数相比，后者的参数在传递到 out 参数之前不必显式初始化。属性不是变量，不能作为 ref 参数传递。如果两种方法的声明仅在它们对 ref 的使用方面不同，则将出现重载。但是，无法定义仅在 ref 和 out 方面不同的重载;

方法参数上的 out 方法参数关键字使方法引用传递到方法的同一个变量。当控制传递回调用方法时，在方法中对参数所做的任何更改都将反映在该变量中。当希望方法返回多个值时， 声明 out 方法非常有用。使用 out 参数的方法仍然可以返回一个值。一个方法可以有一个以上的 out 参数。若要使用 out 参数，必须将参数作为 out 参数显式传递到方法。out 参数的值不会传递到 out 参数。不必初始化作为 out 参数传递的变量。然而，必须在方法返回之前为 out 参数赋值。属性不是变量，不能作为 out 参数传递。如果两个方法的声明仅在 out 的使用方面不同，则会发生重载。不过，无法定义仅在 ref 和 out 方面不同的重载;

#### extern是什么意思？
extern修饰符用于声明由程序集外部实现的成员函数，经常用于系统API函数的调用(通过DllImport)。注意，和DllImport一起使用时要加上static修饰符；
也可以用于对于同一程序集不同版本组件的调用(用extern声明别名)；
不能与abstract修饰符同时使用；

#### 对象构造器？
使用对象构造器，可以使初始化对象像初始化数组一样简单，即在构造函数后直接添加多个初始化语句代码，并用逗号分隔，整体用{}括起来，定义形式如下：
类型声明 实例名称 = new 类型名称() ;
如果相同成员的不同初始化语句，则以最右面的语句为准。初始化的顺序是先执行构造函数的语句，然后执行对象构造器中的语句。如下例：
Snake s = new Snake () {name="眼镜蛇"，length=12，weight=20};

#### C#匿名类型的的实际应用？
通过var和对象构造器，声明一个没有名称(其名称是由编译器分配的)的类，同时创建并初始化成员。如：var pc1 = new {cpu="Intel"，memory="AMD"};
如果程序仅仅需要临时一组数据，则用匿名类型比较合适，匿名类型编译后，仍然是一个普通的密封类，不可派生其他类，只是名称是由编译器分配的，利用对象构造器初始化的成员，具有只读属性。匿名内部类同样有构造函数用于初始化成员，只是创建时不需要显式调用；

#### const和readonly区别？
都可以标识一个常量。主要有以下区别：
1、初始化位置不同。const必须在声明的同时赋值；readonly即可以在声明处赋值，也可以在静态构造方法(必须是静态构造方法，普通构造方法不行)里赋值；
2、修饰对象不同。const即可以修饰类的字段，也可以修饰局部变量；readonly只能修饰类的字段；
3、const是编译时常量，在编译时确定该值；readonly是运行时常量，在运行时确定该值；
4、const默认是静态的；而readonly如果设置成静态需要显示声明；
5、修饰引用类型时不同，const只能修饰string或值为null的其他引用类型；readonly可以是任何类型；
如果类型限制了不能在编译时确定它的值，可以使用static readonly来代替；

#### 请解释virtual的含义?
virtual 关键字用于修改方法或属性的声明，在这种情况下，方法或属性被称作虚拟成员。虚拟成员的实现可由派生类中的重写成员更改。调用虚方法时，将为重写成员检查 该对象的运行时类型。将调用大部分派生类中的该重写成员，如果没有派生类重写该成员，则它可能是原始成员。默认情况下，方法是非虚拟的。不能重写非虚方 法。不能将 virtual 修饰符与以下修饰符一起使用：static abstract override除了声明和调用语法不同外，虚拟属性的行为与抽象方法一样；
在静态属性上使用 virtual 修饰符是错误的；
通过包括使用 override 修饰符的属性声明，可在派生类中重写虚拟继承属性；

#### sealed、new、virtual、abstract与override关键字的区别？
1、sealed修饰类代表密封类，不能被继承，修饰方法代表密封方法，不能被重写。通常用于实现第三方类库时不想被客户端继承，或用于没有必要再继承的类以防止滥用继承造成层次结构混乱；
2、new 显式隐藏基类的成员。不用new隐藏基类的成员也可以，但会给出警告；
3、virtual为了子类来重写的，子类需要override，如果不用会给个警告；
4、abstract可以修饰类，方法，属性，索引器及事件；
5、override子类重写基类的abstract，virtual成员，不能重写非虚拟方法或静态方法；

#### new和override相同点和区别？
相同点：都可以对基类成员进行隐藏，都可以用base调用基类的成员；
不同点：
1、用override重写基类的方法，要求与基类必须有完全相同的访问修饰符、返回值类型和方法名称名称，参数，异常。new则不用；
2、用override重写基类的方法，要求基类的方法必须为虚拟的，抽象的或重写的(virtual，abstract，override)，而new不必要；
3、继承后，用一个基类的对象调用基类的virtual方法时，override重写的子类方法会被访问，而new重写的子类方法不会被访问(只访问基类的virtual方法)；
4、new作为运算符时，创建对象，调用构造函数。new 用于约束时 用于在泛型声明中，约束指定泛型类声明中的任何类型参数都必须有公共的无参数构造函数；