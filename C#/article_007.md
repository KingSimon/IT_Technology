# C# 中的加框与去框(装箱与拆箱)
C# 运行时中有两种类型：引用类型（reference)（在 C# 中用类声明)和值类型(value)（在 C# 中用结构声明）。引用和值类型在几个重要方面有所不同。值类型“感觉上”象一个数据。它包括预定义数值类型（如int、bool）以及用户定义的类型（circle、Point等）。如上文所述，值类型的变量是实际的值，所以在您使用变量时，通常处理的是实际的值。


### 1. 首先，让我们来看一看值类型(value)（在 C# 中用结构声明）。

对于任何类型的非框机构都又如下的形。

```
//-------------------------------------
struct T_Point
{
T x,y;
T_Point(T x,y) {
this.x=x;
this.y=y
}
}
//-------------------------------------
```
sample:
```
class test{
struct Point
{
public int x, y;
public Point(int x, int y) {
this.x = x;
this.y = y;
}
}
public static void Main()
{
Point p = new Point(10, 10);
object f = p;
p.x = 20;
Console.Write(((Point)f).x);
Console.Write(p.x);
}
}
```
让我么来看一看最后的结果是什么？结果是10,20.在第二次指定变量后，两个独立的变量包含相同的值。
修改 p 的值不会改变 f 的值.

### 2. 引用类型用于所有不能用作值类型的对象。引用类型的变量指向堆中对象的实例。这意味着在将一个变量指定
给另一个变量时，只是指定了引用，而不是值。

对于任何类型的框类都又如下的形。
```
//------------------------------------------------------
class T_Point
{
T x,y;
T_Point(T x,y) {
this.x=x;
this.y=y
}
}
//--------------------------------------------------------
```
```
class test{
class Point
{
public int x, y;
public Point(int x, int y) {
this.x = x;
this.y = y;
}
}
public static void Main()
{
Point p = new Point(10, 10);
object f = p;
p.x = 20;
Console.Write(((Point)f).x);
Console.Write(p.x);
}
}
```
让我么来看一看最后的结果是什么？很奇怪吗，结果是20,20.在第二次指定变量后，p 和 f 指向同一对象。这意味着修改 p 的名称也将改变 f 的名称，因为它们引用同一实例。修改类值的成员称为“变更者”，而不具有任何变更者的类称为不可变类。不可变类的存在可以使类的行为类似于值类，但不能写入为值类。

在c#语言中同时使用引用和值两种类型是很重要的。值类型轻便高效，而引用类型适用于面向对象的开发。但是，尽管我们有两了种类型，但有时我们需要的是更为简单的模型，使用单一的、能够囊括所有可能值的类型。这样一个通用基类能够调用任何值的虚函数。写入能够存储任何值的集合类。为实现这一目的，c#语言运行时采用一种方法让值类型在需要时转化为引用类型，即通过称为加框的进程。被加框的类型是通用基类，可以被各种类型的对象引用。


### 解框


```
int i = 123;
object k = i;// 将 int i 加框到对象 k 中
int j=(int)k; // 解框 k 到 value2
```

当赋值给 k 时，作为赋值的一部分，C# 编译器将创建足够容纳堆中 int 的引用类型包装，将值复制到该加框，然后将加框标记为实际类型，以便运行时了解加框的类型。要从加框中取值，必须使用强制类型装换来指定加框的类型（对象能够保留任何类型）。在执行过程中，运行时将检查对象变量引用的类型是否为强制类型转换
中指定的类型。如果类型正确，值将从加框中复制回值类型变量。如果类型不正确，将导致异常。请注意解除加框过程中不会进行其他转换；类型必须完全匹配。

请注意以下代码：


```
long i = 123;
object k = i;// 将 long i 加框到对象 k 中
ulong j=(ulong)k;
```

由于加框类型于解框类型的不同将出错。如果认为像c++语言一样下面的操作将正确那也是不对的。

```
long i = 123;
object k = i;
int j=(int)k;
```


最后总结一下加框和解框。加框和解框使编写和使用具有通用对象参数的函数变得简单而直接。